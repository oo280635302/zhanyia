20211213:
    问题1:
        与领导1下楼拿外卖，问了常规问题，但是由于内心的自卑让对话导向了让自己阴暗的方向，同时语塞，导致整个对话很尴尬，留下不好影响。
    解决:
        如有预感会出现两人单独的情况，应该事先预警准备一些有正面意义或者无关紧要的话题
        对于常规话题，不应该用阴暗的态度去聊天，就算没有也应该创造出积极的聊天方向，由于自己思维容易堵塞容易让话题聊不下去，应该及时想到另外的话题(如游戏之类)
        除非是对方也是不善言语的人，都应该尽力去聊天，不要让气氛安静下来

    问题2:
        同事1主动聊有贬低性质的话题，摸不清其内心想法，选择了与他一起贬低，但整个话题并没有收获到发泄的心态恢复，反而因为态度的模糊导致整个话题阴暗。
    解决:
        尽量避免讨论有贬低性质的话题
        模糊语言

20211214:
    问题1：
        与同事2一起上电梯，昨天有预备的共同学习话题，但是由于说话方式不圆润没有导致聊天过程达到预想的期望
    解决：
        修饰自己说话的方式，减少棱角去峰，既然要打开话题就让话题愉快。

    醒悟1:
        不要批评/评判别人，除了放泻情绪外，别人不会因此而改变，同时会影响自身的形象。
        记得遇到别人对你评判另外一个人，记得不要深入及时转移话题。
        这条需要自我做出较强的自我控制方能做到。

20211215:
    醒悟1：
        发现别人的自重的地方，学会针对别人的自重的地方称赞别人，满足别人的自重感。
        要赞赏，而不是谄媚，这个度要把握好。

20211218:
    醒悟1:
        多去想别人需要什么，而不是自己需要什么，这样才能增加自己的价值。
        包括很多表述能力上，其实都是可以作为以他们为目的让他们获取的利益的表述上来表达，而不是用自己的需求的表诉上来表达。（换一种说话的方式，思维）

    醒悟2：
        要对别人感兴趣，让别人感受到你对他的尊重，真诚！

20211220:
    醒悟1：
        要面露微笑


20220209 蓝信移动面试：
    1.一面：
        1. grpc原理，为什么选用grpc而不是http，grpc的缺点?为什么跟据http2实现
            答：1.grpc使用protobuf解析后的二进制传输，效率更快，http使用文本传输
                  grpc强类型约束了数据类型，更稳定
                  grpc调用隐掉了服务间调用的网络通信过程，对代码的侵入性低，更简洁明了
                  grpc的缺点是不兼容
                2.因为http2是经过实验更完整的方案
                  支持更高级的stream，更通用一点，比如设置优先级
                  更安全，http2支持ssl
                  更容易被多语言的客户端实现，主流编程语言应该都有http2的实现

        2. http1.X 和 http2.0的区别
            答: http2可以多路复用，减少资源消耗
                http2二进制传输
                http2压缩header信息 用zip压缩后再发送，同时客户端和服务器端同时维护一张头信息表，所有字段都记录在这张表中，
                这样后面每次传输只需要传输表里面的索引Id就行，通过索引ID查询表头的值
                HTTP2支持服务器推送

        3. tcp与udp的区别，tcp为什么称为可靠传输
            答: UDP 与 TCP 的主要区别在于 UDP 不一定提供可靠的数据传输。
                TCP为什么可靠：
                    保持虚拟连接，ping维护连接的活性
                    保证数据正确且有序的传输，
                        ACK确认机制
                        超时重传
                        滑动窗口保证有序
                    拥塞控制，保证较大的传输效率，不让流量传输出问题
        4. mysql的索引有那些，为什么选用B+tree，B+tree 与 B-tree相比为什么更适用mysql

            答：索引类型：（1）B-Tree索引
                         （2）哈希索引
                         （3）空间数据索引（R-Tree）
                         （4）全文索引
                为什么选用B+tree：
                    目录结构，物理层面更适用于磁盘io
                    子节点链表相连，更有效率的范围查询
                    较少的空间结构减少内存占用
                B+tree的数据保存在子节点上，意味着消耗更少的空间，查询性能更稳定，B-tree的数据保存在叶子节点上，
                范围查询b-tree需要中序遍历一层一层往上找，b+tree只需要找到头子节点然后用链表往后找就行了。
        5. channel原理
            -写入流程
                1、锁定整个通道结构。
                2、确定写入。尝试recvq从等待队列中等待goroutine,然后将元素直接写入goroutine。
                3、如果recvq为Empty,则确定缓冲区是否可用。如果可用,从当前goroutine复制数据到缓冲区。
                4、如果缓冲区已满,则要写入的元素将保存在当前正在执行的goroutine的结构中,并且当前goroutine将在sendq中排队并从运行时挂起。
                5、写入完成释放锁。
            -读取流程
                1、先获取channel全局锁
                2、尝试sendq从等待队列中获取等待的goroutine,
                3、 如有等待的goroutine,没有缓冲区,取出goroutine并读取数据,然后唤醒这个goroutine,结束读取释放锁。
                4、如有等待的goroutine,且有缓冲区（此时缓冲区已满）,从缓冲区队首取出数据,再从sendq取出一个goroutine,将goroutine中的数据存入buf队尾,结束读取释放锁。
                5、如没有等待的goroutine,且缓冲区有数据,直接读取缓冲区数据,结束读取释放锁。
                6、如没有等待的goroutine,且没有缓冲区或缓冲区为空,将当前的goroutine加入recvq排队,进入睡眠,等待被写goroutine唤醒。结束读取释放锁。
            -select
                -原理: 监听和channel有关的IO操作,当 IO 操作发生时,触发相应的动作
                -select从channel中读出数据的顺序是随机的
            -range
                -可以持续从channel读取数据,一直到channel被关闭,当channel中没有数据时会阻塞当前goroutine,与读channel时阻塞处理机制一样
            -deadlock
                指两个或两个以上的协程的执行过程中,由于竞争资源或由于彼此通信而造成的一种阻塞的现象。
                在非缓冲信道若发生只流入不流出,或只流出不流入,就会发生死锁
                -避免: 写的时候注意即可
            -goroutine抢占P
                -链接: https://segmentfault.com/a/1190000040232354
                1.如果存在系统调用超时: 存在超过 1 个 sysmon tick 周期（至少 20us）的任务,则会从系统调用中抢占 P。
                2.如果没有空闲的 P: 所有的 P 都已经与 M 绑定。需要抢占当前正处于系统调用之,而实际上系统调用并不需要的这个 P 的情况,会将其分配给其它 M 去调度其它 G。
                3.如果 P 的运行队列里面有等待运行的 G,为了保证 P 的本地队列中的 G 得到及时调度。而自己本身的 P 又忙于系统调用,无暇管理。此时会寻找另外一个 M 来接管 P,从而实现继续调度 G 的目的。
        6. goroutine调度原理
            -调度:
                -正常:
                    1M拿取1P,运行P的1G,其余的G存放在P的runqueue等待
                    当前G运行完自己的时间片后让出P回到runqueue
                -阻塞:
                    当G执行syscall时会M阻塞,如果当前P有G需要执行,runtime会把M从P种detach,然后创建新M服务P
                -拿取:
                    当M获取到P没有G时,M会从全局队列中拿一批G到P中执行,拿不到会进行"偷取"操作
                -偷取:
                    当P没有可执行G时,会从其他P偷上下文来执行
                -寄存:
                    当G时间片执行完后,没执行完成 会保存当前寄存器执行动作在G身上 以便于下次被调度后再次执行
            -流程:
                1、我们通过 go func()来创建一个goroutine；
                2、有两个存储G的队列,一个是局部调度器P的本地队列、一个是全局G队列。新创建的G会先保存在P的本地队列中,如果P的本地队列已经满了就会保存在全局的队列中；
                3、G只能运行在M中,一个M必须持有一个P,M与P是1: 1的关系。M会从P的本地队列弹出一个可执行状态的G来执行,如果P的本地队列为空,就会想其他的MP组合偷取一个可执行的G来执行；
                4、一个M调度G执行的过程是一个循环机制；
                5、当M执行某一个G时候如果发生了syscall或则其余阻塞操作,M会阻塞,如果当前有一些G在执行,runtime会把这个线程M从P中摘除(detach),然后再创建一个新的操作系统的线程(如果有空闲的线程可用就复用空闲线程)来服务于这个P；
                6、当M系统调用结束时候,这个G会尝试获取一个空闲的P执行,并放入到这个P的本地队列。如果获取不到P,那么这个线程M变成休眠状态, 加入到空闲线程中,然后这个G会被放入全局队列中。

        7. 切片扩容原理
            当需要的容量cap大于两倍旧容量doublecap时, 我们申请的新容量就是需要的容量
            当需要的容量cap小于两倍旧容量doublecap时, 判断是否旧切片的长度小于1024, 如果小于1024, 那么newcap = 两倍旧cap, 直接翻倍
            当旧切片的长度 >= 1024时, 会反复地增加25%，直到新容量newcap超过所需要的容量cap。 其中newcap > 0 是防止int类型溢出, 如果溢出那么就直接newcap = cap(需要的容量)
        8. map实现原理
            答:讲下hash拉链算法，讲下扩容机制
        9. protoBuf的优缺点
            答: 优 1. 性能好/效率高
                   2. 有代码生成机制
                   3. 多种编程语言支持
                缺 1. 可读性差
                   2. 通用性差
        10. redis的数据类型，zset底层数据结构
            答: string,hash,set,zset,list,geo
                zset使用
        算法1：
            比较两个版本号
            答：双指针
    2.二面：
        1. 问项目，遇到的困难如何解决的，为什么要怎么做
        算法1：
            二叉树的高度，不能用递归
            答：层次遍历
        算法2：
            LRU实现，读和写io为1
            答: 双数据结构 Map + 双向链表

20220210 乌圆：
    技术面
        1.自我介绍
        2.kafka怎么保证只消费一次
            答: 幂等
                生产方每一个生产者一个唯一的 ID，并且为生产的每一条消息赋予一个唯一 ID

        3.mongoDB各种问题

20220212 星合互娱：
    技术面：
        1.mysql的锁有哪些?区别
        2.mysql的innodb和myisam的区别
        3.kafka的消费组 各名次概念
        4.mysql的binlog
        5.golang的CSP
        6.golang的锁有那些
        7.golang的syncMap底层实现
        8.redis的内存回收
        9.redis的skiplist的插入
            如果正常的skiplist，插入后他后面的数据都要重排
            redis的skiplist做了个随机层数，直接找到对应位置插入，logn
        10.为什么选用redis做缓存
    算法题：
        一堆重复数字里面找出不同的数字，不能用map
        答：排序+比较