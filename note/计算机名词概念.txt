操作系统下载：MSDN,
镜像：UltraISO
canvas :https://github.com/hustcc/canvas-nest.js  棍棍跟着走
翻墙软件：ssr ,网址：clssr.cn
		  expressVPN 网址：www.expressVPN.com
搭建一个本地服务器环境：访问HTTP协议：phpstudy
编辑器live Templates自定义写法
抓包：share wire
百度文库转pdf：冰点软件

1.文件的概念：	
	-分类：文本文件,二进制文件
	-图片文件,视频文件,音频文件都属于二进制文件
	-编辑器不能打开二进制文件	

2.异步
	-概念：当一个异步发出后不能直接调用,需要轮训和被调方通知才能调用

3.轮训
	-概念：不断的请求异步事件,直到请求成功调用的过程

4.阻塞与非阻塞
	-阻塞：消息发送后,会一直等待接收了才进行下一步
	-非阻塞：消息发送后,可以进行其他事情.
	
5.I/O多路复用
	-概念：单线程,通过记录跟踪每个I/O流(sock)的状态,来同时管理多个I/O流.
	-I/O的方式：
		-select与poll
			-当有I/O产生时,通过轮训的方式遍历整个进程
		-epoll
			-当有I/O产生时,返回进程里面那个I/O被触发了,不需要轮训
	-
	epoll:
        epoll有EPOLLLT和EPOLLET两种触发模式,LT是默认的模式,ET是"高速"模式.
        LT模式下,只要这个fd还有数据可读,每次 epoll_wait都会返回它的事件,提醒用户程序去操作,而在ET（边缘触发）模式中,它只会提示一次,直到下次再有数据流入之前都不会再提示了,
        无论fd中是否还有数据可读.所以在ET模式下,read一个fd的时候一定要把它的buffer读光,也就是说一直读到read的返回值小于请求值,或者遇到EAGAIN错误.
        还有一个特点是,epoll使用,"事件"的就绪通知方式,通过epoll_ctl注册fd,一旦该fd就绪,内核就会采用类似callback的回调机制来激活该fd,epoll_wait便可以收到通知.
	
6.多线程并发
	-概念：每个I/O流用一个线程
	
7.常见请求响应结果
	-200	请求成功
	-300	多种选择
	-400	错误请求(语法错误)
	-404	未找到网页
	-405	方法禁用
	-500	服务器内部的错误	

8.base64编码
	-格式: data:image/png;base64,....
	-引入base64编码的图片
	-优势与普通图片：是字符串,浏览器能解析成图片,特别小
	
9.方向	
		编译原理->数据结构->数值分析

10.运行 里面打开 服务
	输入services.msc 
	
11.Windows里面的Linux子系统
	-Windows商城搜索linux,安装即可
	-windows程序与linux程序会互用
		
12.堆栈
    - 在程序中的意思
        -堆      未知内存大小,需要程序员自己创建释放的数据类型      eg:slice
        -栈      已知使用内存大小,不需要程序员开辟内存空间的数据类  eg:int
	- 在数据结构上的意思
        -堆      随意取放
        -栈      后进先出(桶)
		-队列    先进先出(管道)
		
13.跨域
    - 同源协议
        -防止一个域javaScript脚本和其他域的内容进行交互
        -限制：无法读取非同源 缓存cookie,本地存储localStorage,索引数据库indexedDB,文档模型Dom
               无法向非同源地址发送ajax请求
    - 同域
        -协议,域名,端口 一致 称为同域
    - 解决跨域问题
        -同主域,不同子域 ,浏览器会检测document.domain设置是否相同
		-发送窗口协议window.postMessage
		-JSONP
		-CORS

14.守护进程
    - 守护进程是为了保护另外一个进程的持久化
        eg:进程A监控进程B,发现进程B异常退出的时候就自动重启进程B
		
15.dll文件
    -动态库

16.调用链追踪
    -动态展示 一个请求的完整调用的过程.
		
17.istio/linkerd
    -服务网格设计的开源项目
    -作用：将 服务发现/负载均衡/服务认证/服务监控 抽象出来实现

18.前中后序遍历
    -前序遍历
        -中左右
        -在第一次遍历到节点时就执行操作,一般只是想遍历执行操作（或输出结果）可选用先序遍历
    -中序遍历
        -左中右
        -根据树的顺序特征--为了使用排序好的结果 使用中序遍历
    -后序遍历
		-左右中
	    -后续遍历的特点是执行操作时,肯定已经遍历过该节点的左右子节点,故适用于要进行破坏性操作的情况,比如删除所有节点

19.总线锁/缓存锁
    -总线锁：
        多CPU运行,发起总线锁,其他处理器被阻塞,那么该处理器独占共享锁
    -缓存锁：
        数据回写时,不声明锁总线,而是直接修改内存地址,利用缓存一致性保证操作原子性
    -缓存一致性：
        当内存由多个CPU缓存时,回写内存,会使该缓存失效invalid
    -场景:
        缓存锁：一般能缓存锁就缓存锁
        总线锁：数据无法被缓存,数据多个缓存行,处理不支持缓存锁

20.GCCGO/GC
    -GC:
        GO原生编译器,编译效率快,只支持主流处理器X86、amd
    -GCCGO:
        传承于GCC编译器,需要自己安装,编译速度慢,编译后代码执行效率高,优化好,能编译版本相对滞后,对ARM架构提供更稳定,缺少逃逸检测(小内存分配会有影响)
    -总结：
        一般就用GC,优化性能用GCCGO


21.golang逃逸分析
    -逃逸：
        栈(局部)上变量因为(数据太大,需要返回数据...)原因分配在了堆上(全局)
        如果堆上数据分配不好,容易对gc造成压力,有内存碎片
    -GO逃逸原则：
        如果一个函数返回的是一个（局部）变量的地址,那么这个变量就发生逃逸
    -逃逸分析：
        逃逸分析是一种确定指针动态范围的方法,可以分析在程序的哪些地方可以访问到指针.
        逃逸分析需要确定指针所有可以存储的地方,保证指针的生命周期只在当前进程或线程中.
    -逃逸分析的好处：
        -优化性能
        -最大的好处应该是减少gc的压力,不逃逸的对象分配在栈上,当函数返回时就回收了资源,不需要gc标记清除.
        -因为逃逸分析完后可以确定哪些变量可以分配在栈上,栈的分配比堆快,性能好
        -同步消除,如果你定义的对象的方法上有同步锁,但在运行时,却只有一个线程在访问,此时逃逸分析后的机器码,会去掉同步锁运行
    -逃逸优化：
        本身就是为了隐藏这层减少工作量的,只能针对代码上对一些变量进行特殊处理
        //go:noescape  -- 同时会使变量在函数使用后自动到期,慎重考虑后使用

22.决策树/随机森林
    -

23.AI决策算法：
    -有限状态机FSM
        -概念:
            其在任意时刻都处于有限状态集合中的某一状态.
            当其获得一个输入字符时,将从当前状态转换到另一个状态,或者仍然保持在当前状态。
            任何一个FSM都可以用状态转换图来描述,图中的节点表示FSM中的一个状态,有向加权边表示输入字符时状态的变化。
        -实现：
            使用状态转换图描述FSM
            状态转换图中的结点对应不同的状态对象
            每个状态对象通过一个输入字符转换到另一个状态上，或者保持原状态不变。
            通过输入字符从一个状态切换到另一个状态的过程，我们称之为一个映射。在计算机程序设计中，我们可以有两种表示映射的方法：
            通过算法表示，即“可执行代码（Executable Code）”方式
            通过一张映射表，即“被动数据（Passive Data）”方式
    -GOAP
        -概念:
            目标导向型行动计划（简称GOAP）是一种能够轻松呈现给你的代理选择的AI系统，
            也是帮助你可以无需维持一个庞大且复杂的有限状态机而做出明智的决策的机器