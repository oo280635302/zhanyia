
  1.常用的负载均衡的算法
    -随机数
    -一致性hash：
        应用为 nagix
        性能一般1
        一致性：
    -加权hash:
        分权重的负载方式
        性能较好
    -轮询
        将所有请求，依次分发到每台服务器上，适合服务器硬件相同的场景。
        优点：服务器请求数目相同；
        缺点：服务器压力不一样，不适合服务器配置不同的情况；
     -随机
        请求随机分配到各台服务器上。
        优点：使用简单；
        缺点：不适合机器配置不同的场景
     -最少链接
        将请求分配到连接数最少的服务器上（目前处理请求最少的服务器）。
        优点：根据服务器当前的请求处理情况，动态分配；
        缺点：算法实现相对复杂，需要监控服务器请求连接数；
     -Hash（源地址散列）
        根据IP地址进行Hash计算，得到IP地址。
        优点：将来自同一IP地址的请求，同一会话期内，转发到相同的服务器；实现会话粘滞。
        缺点：目标服务器宕机后，会话会丢失；
    -加权
        在轮询，随机，最少链接，Hash等算法的基础上，通过加权的方式，进行负载服务器分配。
        优点：根据权重，调节转发服务器的请求数目；
        缺点：使用相对复杂；

  2.微服务的架构特点
    -将系统服务器层完全独立出来,并将服务层抽取为一个一个的微服务
    -采用一些轻量协议进行传输
    -服务拆分粒度更细,有利于资源重复利用,提高开发效率
    -可以更加精准的制定每个服务的优化方案,提高系统可维护性
    -相比ESB更轻量
    特点：
        -职责单一
        -轻量级通讯
        -隔离性
        -有自己的数据
        -技术多样性

  3.递归，贪心，分治，深搜广搜，双指针，动态规划，枚举
    -解决恶心的算法问题
    -干就完了

  4.tcp连接
    -三次握手
    -主要是理解其原理是为什么

  5.mysql的隔离级别
    read uncommitted 读未提交(最低隔离级别)
    -一个事务还没提交，另一个事务就可以读取到，"dirty read"
    read committed 读已提交（2级）
    -一个事务提交了的数据，另一个事务才能读取到，不可重复读，oracle默认
    repeatable read 可重复读（3级）
    -一个事务提交的数据，另一个事务读取不到，可重复读，Mysql默认
    serializable 串行化（4级）
    -一个事务读书时，另一个事务只能排队等，效率低，

  6.mysql索引类型
    -普通索引   key
    -唯一索引   unique key
    -主键索引   primary key
    -组合索引
    -全文索引   fulltext

  7.锁
    -对象锁：单个实例被访问时会受影响，但是多个实例多个线程不受影响
    -自旋锁：一个线程获得锁后，另外一个线程重复不断的试探该锁 -- 浪费cpu
    -互斥锁：一个线程获得锁后，另外一个线程要等待释放后才能使用 -- 相对自旋使用资源少很多
    -类锁：全局锁 多实例一个线程
    -共享锁：读写，读读，写写分离，各自互斥，各自加锁
    -分布式锁：利用redis
        -死锁的解决： 要有失效时间 减少获取锁的次数 持锁时check


  8.SaaS
    -软件服务化
    -更加需要软件通用性，可组件化开发

  9.哈希表 复杂度 解决hash碰撞的方法
    -散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。
     给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。
    -建表复杂度O(n)
    -查找复杂度O(1)
    -hash碰撞：对不同的关键字可能得到同一散列地址
        -解决碰撞的方法：
            -拉练法
            -开放寻址
            -再哈希
        -拉链法：
            -根据hash长度建立一个由该长度相同一维数组，将地址相同的都插入该数组i的链表里面
            -优点：
                -拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；
                -由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；
            -缺点：因为需要开辟地址，所以会有所浪费空间
        -开放寻址法：
            -将所有元素都存储在散列表中，要系统的检查所有的表项，直到找到所需的元素，或者所需的不在表中
            -需要先探查，探查方法：线性探查-找到自己的位置然后查看是否有值，有就加一个值
            -优点：节约空间
            -缺点：数据量大，时间成本越高

  10.红黑树
    -特殊的二叉查找树，满足二叉查找树
    -任意一个节点所包含的键值，大于等于左孩子的键值，小于等于右孩子的键值
    -不能有两个相同的红结点，根结点必须是黑结点,所有结点通向null上的黑节点数量相同
    -复杂度：增删查 log(n)
    -应用比较广泛，主要是用它来存储有序的数据

  11.对微服务的了解
    -微服务是一个近些年说的非常热的概念，去中心化，无状态，独立服务，隐藏内部细节，自动化
    -潜在问题：
        -数据的一致性：
            解决方法：重试机制，补偿机制，TCC软状态
        -容错性：
            解决方法：超时机制，隔离，断路保护（计算失败请求次数）
        -系统的性能：
            解决方法：多用redis，RPC通讯
        -实施复杂：
            解决方法：cicd自动部署

  12.redis
    -sort set
        -复杂度 增删改logn 查1
        -数据结构：ziplist数据少时,skiplist数据多时，dict
        -数据存储过程：查找是否存在，然后先删后增，然后考虑是否升级为skiplist,是否更新dict
    -set
        -复杂度：增删n 取1
        -数据结构：intset，hashtable

    -hash
        -复杂度：增查改1，删n
        -数据结构：ziplist数据少时，hashtable数据多时

    -list
        -复杂度：增取1，删指定n
        -数据结构：ziplist，linkedlist双向列表

    -string:
        -复杂度：增改查1，删n
        -数据结构：大的hashMap,冲突根据挂链解决

  13.项目相关均可能会被问到
    -提前给面试官找个坑  让他问
    -如他说遇到什么大的bug吗
        -map这点 可以大写特写
            -map并发读写报错：解决加锁，用channel
            -map的内存泄漏,delete删除map键值,实际并没有释放，解决方法：定期换新map,释放旧map


  14.rabbitMq 如何保证数据的可靠性
    3步：
    -开始时：confirm 单confirm 多confirm 异confirm
    -发送中时：-一般会放在内存里，设置持久化，就算rabbitMq崩溃了 也能恢复
    -消息处理失败：重发，取消autoack

  15.组件化 模块化开发
    -组件：最初的目的是代码重用，功能相对单一或者独立。在整个系统的代码层次上位于最底层，被其他代码所依赖，所以说组件化是纵向分层。
    -模块：最初的目的是将同一类型的代码整合在一起，所以模块的功能相对复杂，但都同属于一个业务。不同模块之间也会存在依赖关系，但大部分都是业务性的互相跳转，从地位上来说它们都是平级的

  16.分布式与高并发
    -dns        -分配最好的系统
    -系统拆分    -整体分散
    -数据库缓存  -程序->数据库间 增加redis
    -mq         -实现消息顺序 和不丢失
    -分库分表    -哪一个表数据太大了，查询困难，单服务用单数据库
    -读写分离    -主从数据库， 主负责写入数据， 从负责读取数据

  17.MySQL 百万数据量分页查询方法 优化
    -直接使用数据库提供的SQL语句
    -建立主键或唯一索引, 利用索引(假设每页10条)
    -基于索引再排序
    -基于索引使用prepare
    -利用MySQL支持ORDER操作可以利用索引快速定位部分元组,避免全表扫描


  18.Mysql 百万数据查询优化
    -尽量 where 后面 只用 =
    -少使用or 可以使用union all 来进行多条件
    -尽量 避免查询带null的字段
    -对于连续的数值，能用 between 就不要用 in
    -少用 like or > < != 等
    -不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引

  19.索引方式:
    -b-tree  支持 myisam 和 innodb
        -innodb
            -primary key 其叶结点存放索引数据 + 其他字段数据
            -secondary index 存放的指向主键的信息
        -myisam
            -leaf node存指向数据文件里的对应数据行的信息
    -hash   支持 memory  ndb cluster  *innodb
        -特点:
            -hash索引 根据hash表实现 查询条件需要匹配hash所有列才能用到hash索引
            -hash 会为每一行计算一个hash码,hash索引存储的是hash码
            -hash索引包括键值、hash码和指针
        -限制：
            -二次查找:
                先找对应行, 再读取数据
                对数据库性能影响不大
            -不能外排序
                用的hash码,而不是键值
            -只能用等值查找-不能范围查找
            -容易出现hash冲突
                当出现hash冲突时,会遍历所有行指针逐行比较,代价太大
                选择 索引 时 要选择重复率小的,唯一最好
        -innodb的hash较为特殊
            -伪装的hash列表 还是b-tree索引
            -不过在Btree的基础上使用hash值来存储+查找
            -查找效率加快
            -缺点:
                需要维护hash值
                CRC32容易出现Hash冲突





















