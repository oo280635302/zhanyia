-------------------------------------------操作系统-----------------------------------------------------
    1.基本概念：
        操作系统：计算机硬件与应用之间的软件
        主要操作：取指执行
        GDT全局描述表：
            在保护模式下一个重要的数据结构,唯一,CPU必须知道GDT的入口

    2.操作系统开机启动流程：
        boot -> setup -> head -> main -> xx_init(硬件的操作初始)


    3.操作系统的接口os interface
        如何使用计算机：
            命令行、图形按钮、应用程序
        调用操作系统提供的接口函数：
            系统调用：
                fork                创建一个进程
                execl               运行一个可执行程序
                pthread_create      创建一个线程
                open                打开一个文件或目录
                mode_t st_mode      文件头结构\文件属性
                EACCES              返回值，表示没有权限
            POSIX操作手册
        系统调用的实现:
            -阻止系统调用与内核中保存的数据交互
                -原因：内存中直接jmp会导致内存中的其他数据也有泄露风险
                -阻止方式：
                    硬件设计时直接隔离，分为：
                        内核态：
                            内核态可以访问任何数据，用户不能访问内核数据
                            DPL=0 权限标记位
                        用户态：
                            CPL=3
                        根据DPL和CPL权限判断不允许其mov/jmp访问
                -提供的主动进入内核的唯一方法：
                    -使用Int指令代码
                    -用户程序将系统函数转换成int指令函数
                    -操作系统写中断处理，获取想调程序的编号
                    -操作系统根据编号执行相应代码

    4.cpu
        多道程序，交替执行，提供cpu利用率
        -进程概念：
            由cpu来执行的正在执行的程序.
            进程需要记录cpu已经操作过的变量，等待cpu继续执行，数据记录于pcb中
            进程资源不共享
        -多进程图像multiple processes
            就是一只知道的任务管理器的进程 很直观了
        -进程状态图：
            新建->就绪->运行->终止   运行->阻塞->就绪
            使用状态推进进程
        -队列操作+调度+切换
            -调度方法：
                FIFO 队列先入先出
                Priority 根据优先级调度
            -切换:
                切换的时候保存数据到PCB里面
        -通过映射表进行内存地址的分离，
            -不同进程的数据在内存中的数据隔离
            -不同进程 对应映射表 对应的位置不同
        -用户级线程thread
            -资源共享缓冲区，交替执行程序
            -create创建线程
                -申请TCB、申请栈
            -yield切换正在执行的线程
                -各自的线程自带栈
                -esp切换当前的TCB
            -设计算法：分治
            -用户级线程：不深入核心，对核心不影响，因此硬件io调度依然很慢
        -内核级线程
            -schedule调度，对应用户级Yield
            -内核线程性能更好，因为内核才能控制硬件资源
            -栈：
                用户栈+内核栈
            -用户栈A -INT中断-> 内核栈1 -TCB内核切换-> 内核栈2 -> IRET中断返回 -> 用户栈B
        -cpu调度策略
            -专注于任务执行，又能合理调用
            -调度算法：
                -FCFS 先来先服务 first come first served
                -SJF 短命令优先
                -RR round robin时间片轮转
        -信号量与临界保护
            -保持进程的同步性使用信号量
            -保证信号量的临界保护
                -硬件原子指令
                    硬件提供的不能被打断的原子性操作
        -死锁处理

    5.内存
        -内存地址到物理地址之间需要重定位
        -重定位:
            -编译时定位： 固定位置
            -载入时定位： 当载入这个操作时才固定位置，相对灵活
            -运行时定位： 当进程运行时，才真正定位
        -分段
        -分区
        -分页




























