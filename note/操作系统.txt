-------------------------------------------操作系统-----------------------------------------------------
    1.基本概念：
        操作系统：计算机硬件与应用之间的软件
        主要操作：取指执行
        GDT全局描述表：
            在保护模式下一个重要的数据结构,唯一,CPU必须知道GDT的入口

    2.操作系统开机启动流程：
        boot -> setup -> head -> main -> xx_init(硬件的操作初始)


    3.操作系统的接口os interface
        如何使用计算机：
            命令行、图形按钮、应用程序
        调用操作系统提供的接口函数：
            系统调用：
                fork                创建一个进程
                execl               运行一个可执行程序
                pthread_create      创建一个线程
                open                打开一个文件或目录
                mode_t st_mode      文件头结构\文件属性
                EACCES              返回值，表示没有权限
            POSIX操作手册
        系统调用的实现:
            -阻止系统调用与内核中保存的数据交互
                -原因：内存中直接jmp会导致内存中的其他数据也有泄露风险
                -阻止方式：
                    硬件设计时直接隔离，分为：
                        内核态：
                            内核态可以访问任何数据，用户不能访问内核数据
                            DPL=0 权限标记位
                        用户态：
                            CPL=3
                        根据DPL和CPL权限判断不允许其mov/jmp访问
                -提供的主动进入内核的唯一方法：
                    -使用Int指令代码
                    -用户程序将系统函数转换成int指令函数
                    -操作系统写中断处理，获取想调程序的编号
                    -操作系统根据编号执行相应代码

    4.cpu
        多道程序，交替执行，提供cpu利用率
        -进程概念：
            由cpu来执行的正在执行的程序.
            进程需要记录cpu已经操作过的变量，等待cpu继续执行，数据记录于pcb中
            进程资源不共享
        -多进程图像multiple processes
            就是一只知道的任务管理器的进程 很直观了
        -进程状态图：
            新建->就绪->运行->终止   运行->阻塞->就绪
            使用状态推进进程
        -队列操作+调度+切换
            -调度方法：
                FIFO 队列先入先出
                Priority 根据优先级调度
            -切换:
                切换的时候保存数据到PCB里面
        -通过映射表进行内存地址的分离，
            -不同进程的数据在内存中的数据隔离
            -不同进程 对应映射表 对应的位置不同
        -用户级线程thread
            -资源共享缓冲区，交替执行程序
            -create创建线程
                -申请TCB、申请栈
            -yield切换正在执行的线程
                -各自的线程自带栈
                -esp切换当前的TCB
            -设计算法：分治
            -用户级线程：不深入核心，对核心不影响，因此硬件io调度依然很慢
        -内核级线程
            -schedule调度，对应用户级Yield
            -内核线程性能更好，因为内核才能控制硬件资源
            -栈：
                用户栈+内核栈
            -用户栈A -INT中断-> 内核栈1 -TCB内核切换-> 内核栈2 -> IRET中断返回 -> 用户栈B
        -cpu调度策略
            -专注于任务执行，又能合理调用
            -调度算法：
                -FCFS 先来先服务 first come first served
                -SJF 短命令优先
                -RR round robin时间片轮转
        -信号量与临界保护
            -保持进程的同步性使用信号量
            -保证信号量的临界保护
                -硬件原子指令
                    硬件提供的不能被打断的原子性操作
        -死锁处理

    5.内存
        -重定位：
            -概念：
                重定位就是把程序的逻辑地址空间变换成内存中的实际物理地址空间的过程，也就是说在装入时对目标程序中指令和数据的修改过程。
                他是实现多道程序在内存中同时运行的基础。
            -分类：
                1、静态重定位：
                    即在程序装入内存的过程中完成，是指在程序开始运行前，程序中的各个地址有关的项均已完成重定位，地址变换通常是在装入时一次完成的，以后不再改变，故成为静态重定位。
                2、动态重定位：
                    它不是在程序装入内存时完成的，而是CPU每次访问内存时 由动态地址变换机构（硬件）自动进行把相对地址转换为绝对地址。动态重定位需要软件和硬件相互配合完成。
            -时机:
                1、程序编译连接时。
                2、程序装入内存时。
                3、程序执行时。
        -分段：
            -每个进程的PCB表都有一个LDT段表，根据LDT段表进行重定位，找到属于自己的代码段，数据段
            -LDT段表就是每个进程的映射表：用于找到属于进程自己的内存段
            -分区：
                -如何找到没有使用的内存
                -将内存分区，需要多少就将数据分开给进程
                -缺点：有碎片的内存，导致内存不能完好的分配
            -分页：
                -将内存分成固定每份，一个段根据大小分配到多个页来内存分配
                -内存在加载的时候就分页
                -寻找内存的页数根据页表，根据cpu自带的MMU计算真实的物理地址
                -多级页表：
                    -为了提供内存利用率，页就应该小，页小页表就大了。因此要分多级
                    -分级后，减少访问时间
                -TLB：
                    -相联快速存储，是各寄存器
                    -类似内存页的缓存器，用于快速找到页框
                    -根据程序地址访问的局部性
        -实际内存管理-段页结合
            -虚拟内存
                -用户程序 -> 分段 -> 虚拟内存 -> 分页 -> 物理内存
                -用虚拟内存来将段与页的概念相结合
                -用户访问的内存为虚拟内存
                -段面向用户，页面向硬件
            -内存的换入swap in/换出swap out
                -换入：
                    -虚拟内存大于物理内存
                    -当用户要访问其中一部分内存时，将数据从磁盘中换入到内存中
                    -请求调页:页号没在物理页号中 使用中断处理 然后从磁盘中将数据swap in内存
                -换出：
                    -换入的内存太多过后，需要将一些内存换出腾空间
                    -方法：
                        -FIFO：先入先出 --简单
                        -MIN：选后面最远将使用的页淘汰 --无法实现
                            -需要预知未来 pass
                        -LRU：最近最长一段时间没有使用淘汰 --代价大，
                            -实现方法：
                                -时间戳，使用时长最小淘汰
                                    -容易溢出
                                -栈
                                    -访问次数太多
                        -SCR：近似LRU的算法  --最终选择
                            -最近一段时间没有被使用淘汰
                            -标记位，当页被使用就标记为1，需要换出时访问 标记为1的置为0，标记的0的就换出
                            -两个指针：1指针速度快清除R位 1->0   1指针速度慢淘汰R位 0->1
                    -颠簸：
                        当进程增多，进程能使用的页数减少，换入换出速度加快，从磁盘中找数据CPU等待加长，缺页率增大
                        解决方法：动态给进程分配页框数，算法：百度

    6.IO设备
        -概念：
            -通过pci总线进行输出输入的设备
            -向设备控制器的寄存器写命令
        -显示器：
            out输出
            库函数print -> 系统调用write -> 字符设备接口crw_table -> tty设备写tty_write -> write_q队列缓冲 -> 显示器写con_write (mov ax,pos)
        -键盘：
            中断处理0x21
            keyboard.s -> read_q队列 ->tty设备读tty_read  ->  字符设备接口crw_table
                                     -> 回显 -> write_q队列
        -磁盘管理
            -生磁盘
            -文件
            -文件使用磁盘的使用
            -目录





