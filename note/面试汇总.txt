20220209 蓝信移动面试：
    1.一面：
        1. grpc原理，为什么选用grpc而不是http，grpc的缺点?为什么跟据http2实现
            答：1.grpc使用protobuf解析后的二进制传输，效率更快，http使用文本传输
                  grpc强类型约束了数据类型，更稳定
                  grpc调用隐掉了服务间调用的网络通信过程，对代码的侵入性低，更简洁明了
                  grpc的缺点是不兼容
                2.因为http2是经过实验更完整的方案
                  支持更高级的stream，更通用一点，比如设置优先级
                  更安全，http2支持ssl
                  更容易被多语言的客户端实现，主流编程语言应该都有http2的实现

        2. http1.X 和 http2.0的区别
            答: http2可以多路复用，减少资源消耗
                http2二进制传输
                http2压缩header信息 用zip压缩后再发送，同时客户端和服务器端同时维护一张头信息表，所有字段都记录在这张表中，
                这样后面每次传输只需要传输表里面的索引Id就行，通过索引ID查询表头的值
                HTTP2支持服务器推送

        3. tcp与udp的区别，tcp为什么称为可靠传输
            答: UDP 与 TCP 的主要区别在于 UDP 不一定提供可靠的数据传输。
                TCP为什么可靠：
                    保持虚拟连接，ping维护连接的活性
                    保证数据正确且有序的传输，
                        ACK确认机制
                        超时重传
                        滑动窗口保证有序
                    拥塞控制，保证较大的传输效率，不让流量传输出问题
        4. mysql的索引有那些，为什么选用B+tree，B+tree 与 B-tree相比为什么更适用mysql

            答：索引类型：（1）B-Tree索引
                         （2）哈希索引
                         （3）空间数据索引（R-Tree）
                         （4）全文索引
                为什么选用B+tree：
                    目录结构，物理层面更适用于磁盘io
                    子节点链表相连，更有效率的范围查询
                    较少的空间结构减少内存占用
                B+tree的数据保存在子节点上，意味着消耗更少的空间，查询性能更稳定，B-tree的数据保存在叶子节点上，
                范围查询b-tree需要中序遍历一层一层往上找，b+tree只需要找到头子节点然后用链表往后找就行了。
        5. channel原理
            -写入流程
                1、锁定整个通道结构。
                2、确定写入。尝试recvq从等待队列中等待goroutine,然后将元素直接写入goroutine。
                3、如果recvq为Empty,则确定缓冲区是否可用。如果可用,从当前goroutine复制数据到缓冲区。
                4、如果缓冲区已满,则要写入的元素将保存在当前正在执行的goroutine的结构中,并且当前goroutine将在sendq中排队并从运行时挂起。
                5、写入完成释放锁。
            -读取流程
                1、先获取channel全局锁
                2、尝试sendq从等待队列中获取等待的goroutine,
                3、 如有等待的goroutine,没有缓冲区,取出goroutine并读取数据,然后唤醒这个goroutine,结束读取释放锁。
                4、如有等待的goroutine,且有缓冲区（此时缓冲区已满）,从缓冲区队首取出数据,再从sendq取出一个goroutine,将goroutine中的数据存入buf队尾,结束读取释放锁。
                5、如没有等待的goroutine,且缓冲区有数据,直接读取缓冲区数据,结束读取释放锁。
                6、如没有等待的goroutine,且没有缓冲区或缓冲区为空,将当前的goroutine加入recvq排队,进入睡眠,等待被写goroutine唤醒。结束读取释放锁。
            -select
                -原理: 监听和channel有关的IO操作,当 IO 操作发生时,触发相应的动作
                -select从channel中读出数据的顺序是随机的
            -range
                -可以持续从channel读取数据,一直到channel被关闭,当channel中没有数据时会阻塞当前goroutine,与读channel时阻塞处理机制一样
            -deadlock
                指两个或两个以上的协程的执行过程中,由于竞争资源或由于彼此通信而造成的一种阻塞的现象。
                在非缓冲信道若发生只流入不流出,或只流出不流入,就会发生死锁
                -避免: 写的时候注意即可
            -goroutine抢占P
                -链接: https://segmentfault.com/a/1190000040232354
                1.如果存在系统调用超时: 存在超过 1 个 sysmon tick 周期（至少 20us）的任务,则会从系统调用中抢占 P。
                2.如果没有空闲的 P: 所有的 P 都已经与 M 绑定。需要抢占当前正处于系统调用之,而实际上系统调用并不需要的这个 P 的情况,会将其分配给其它 M 去调度其它 G。
                3.如果 P 的运行队列里面有等待运行的 G,为了保证 P 的本地队列中的 G 得到及时调度。而自己本身的 P 又忙于系统调用,无暇管理。此时会寻找另外一个 M 来接管 P,从而实现继续调度 G 的目的。
        6. goroutine调度原理
            -调度:
                -正常:
                    1M拿取1P,运行P的1G,其余的G存放在P的runqueue等待
                    当前G运行完自己的时间片后让出P回到runqueue
                -阻塞:
                    当G执行syscall时会M阻塞,如果当前P有G需要执行,runtime会把M从P种detach,然后创建新M服务P
                -拿取:
                    当M获取到P没有G时,M会从全局队列中拿一批G到P中执行,拿不到会进行"偷取"操作
                -偷取:
                    当P没有可执行G时,会从其他P偷上下文来执行
                -寄存:
                    当G时间片执行完后,没执行完成 会保存当前寄存器执行动作在G身上 以便于下次被调度后再次执行
            -流程:
                1、我们通过 go func()来创建一个goroutine；
                2、有两个存储G的队列,一个是局部调度器P的本地队列、一个是全局G队列。新创建的G会先保存在P的本地队列中,如果P的本地队列已经满了就会保存在全局的队列中；
                3、G只能运行在M中,一个M必须持有一个P,M与P是1: 1的关系。M会从P的本地队列弹出一个可执行状态的G来执行,如果P的本地队列为空,就会想其他的MP组合偷取一个可执行的G来执行；
                4、一个M调度G执行的过程是一个循环机制；
                5、当M执行某一个G时候如果发生了syscall或则其余阻塞操作,M会阻塞,如果当前有一些G在执行,runtime会把这个线程M从P中摘除(detach),然后再创建一个新的操作系统的线程(如果有空闲的线程可用就复用空闲线程)来服务于这个P；
                6、当M系统调用结束时候,这个G会尝试获取一个空闲的P执行,并放入到这个P的本地队列。如果获取不到P,那么这个线程M变成休眠状态, 加入到空闲线程中,然后这个G会被放入全局队列中。

        7. 切片扩容原理
            当需要的容量cap大于两倍旧容量doublecap时, 我们申请的新容量就是需要的容量
            当需要的容量cap小于两倍旧容量doublecap时, 判断是否旧切片的长度小于1024, 如果小于1024, 那么newcap = 两倍旧cap, 直接翻倍
            当旧切片的长度 >= 1024时, 会反复地增加25%，直到新容量newcap超过所需要的容量cap。 其中newcap > 0 是防止int类型溢出, 如果溢出那么就直接newcap = cap(需要的容量)
        8. map实现原理
            答:讲下hash拉链算法，讲下扩容机制
        9. protoBuf的优缺点
            答: 优 1. 性能好/效率高
                   2. 有代码生成机制
                   3. 多种编程语言支持
                缺 1. 可读性差
                   2. 通用性差
        10. redis的数据类型，zset底层数据结构
            答: string,hash,set,zset,list,geo
                zset使用
        算法1：
            比较两个版本号
            答：双指针
    2.二面：
        1. 问项目，遇到的困难如何解决的，为什么要怎么做
        算法1：
            二叉树的高度，不能用递归
            答：层次遍历
        算法2：
            LRU实现，读和写io为1
            答: 双数据结构 Map + 双向链表

20220210 乌圆：
    技术面
        1.自我介绍
        2.kafka怎么保证只消费一次
            答: 幂等
                生产方每一个生产者一个唯一的 ID，并且为生产的每一条消息赋予一个唯一 ID

        3.mongoDB各种问题

20220212 星合互娱：
    技术面：
        1.mysql的锁有哪些?区别
            锁粒度来分：行级锁、表级锁、页级锁、间隙锁
                行锁: innodb专用
                    记录锁:
                        锁单行记录，排他
                    间隙锁：
                        锁范围，排他
                    临健锁:
                        记录锁和间隙锁的结合，排他，默认，解决幻读
                表锁： myisam、innodb都支持
                    表读锁：
                        用读锁锁表，会阻塞其他事务修改表数据。
                    表写锁：
                        用写锁锁表，会阻塞其他事务读和写
                页锁：bdb支持
                    一次锁定相邻的一组的数据，介于行锁、表锁之间
            共享策略来分：共享锁、排他锁、意向共享锁、意向排他锁
                共享锁：
                    针对同一份数据，多个读操作可以同时进行而不会互相影响
                排它锁：
                    当前写操作没有完成前，它会阻断其他写锁和读锁
                意向共享锁：innodb
                    当准备加共享锁时，先加个表级别的意向锁
                意向排他锁：innodb
                    当准备加排他锁时，先加个表级别的排他锁
                **意向锁的意义：
                    innodb即存在表锁也存在行锁，当先行锁再表锁的时候，需要遍历所有行锁看是否锁住表锁需要锁的锁，
                    为防止遍历浪费效率，加个意向锁让表锁知道当前表有行锁在操作。

        2.mysql的innodb和myisam的区别
            1.innodb支持事务，myisam不支持
            2.innodb支持外键，myisam不支持
            3.innoDB是聚集索引，myisam是非聚集索引
                聚集索引：主键与磁盘数据物理顺序相同
                非聚集索引：主键与磁盘数据物理顺序不同的，查起来更慢
                InnoDB的B+树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值；
                而MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针
            4.InnoDB不保存表的具体行数，myisam保存全表具体行数
                意味着innodb统计行数是全表扫描
                因为InnoDB的事务特性，在同一时刻表中的行数对于不同的事务而言是不一样的，因此count统计会计算对于当前事务而言可以统计到的行。
                InnoDB会尝试遍历一个尽可能小的索引
            5.MyISAM表格可以被压缩后进行查询操作
            6.InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁
            7.InnoDB表必须有唯一索引，Myisam可以没有
            8.Innodb存储文件有frm、ibd，而Myisam是frm、MYD、MYI
                  Innodb：frm是表定义文件，ibd是数据文件
                  Myisam：frm是表定义文件，myd是数据文件，myi是索引文件

        3.kafka的消费组 各名词概念

        4.mysql的binlog
            二进制日志用于记录了所有的DDL和DML语句（除了查询）
            事务安全，binlog 的主要目的是复制和恢复
            MySQL主从复制：
                Master开启binlog把它的二进制日志传递给slaves来达到master-slave数据一致的目的
            写 Binlog 的时机:
                对支持事务的引擎如InnoDB而言，必须要提交了事务才会记录binlog
                sync_binlog:
                    0  mysql不控制binlog的刷新，由文件系统自己去控制刷新
                    1  每次事务结束都都刷新到磁盘
                    X  每X次事务都刷新到磁盘
            binlog文件:
                二进制日志索引文件（文件名后缀为.index）用于记录所有有效的的二进制文件
                二进制日志文件（文件名后缀为.00000*）记录数据库所有的DDL和DML语句事件
            Binlog 的日志格式:
                Statement：
                    每一条会修改数据的sql都会记录在binlog中
                    优: 日志量少，Io小
                    缺：没法保证某些特定函数执行在slave的一致性
                Row：
                    不记录执行的sql语句的上下文相关的信息，仅记录那一条记录被修改成什么。
                    优：记录了每行记录修改的细节，解决函数调用不一致问题
                    缺：日志量太大
                Mixed：
                    statement+row的集合，一般保存statement日志，特定函数保存row

        5.mysql的主从同步原理：
            1 master服务器将数据的改变记录二进制binlog日志，当master上的数据发生改变时，则将其改变写入二进制日志中；
            2 slave服务器会在一定时间间隔内对master二进制日志进行探测其是否发生改变，如果发生改变，
                则开始一个I/OThread请求master二进制事件
            3 同时主节点为每个I/O线程启动一个dump线程，用于向其发送二进制事件，并保存至从节点本地的中继日志中，
                从节点将启动SQL线程从中继日志中读取二进制日志，在本地重放，使得其数据和主节点的保持一致，最后I/OThread和SQLThread将进入睡眠状态，等待下一次被唤醒。

        6.mysql的分表后查询：
            一般分表都是跟据业务场景进行分表，如果实在不行出现了多个表联合查询的情况可以用union all的查询方式，但是这样既有可能会产生慢sql，
            优化方案是 多条查询然后内存合并 减少慢sql的出现。
            再优化就是引入es使用binlog的同步技术，去查es。

        7.golang的CSP
            基于通信的共享内存方式 channel

        8.golang的锁有那些，死锁的产生
            互斥锁、读写锁
            死锁：一边锁了1等待锁2 另一边锁了2等待锁1

        9.golang的syncMap底层实现
            onlyRead 和 dirty 指向相同的数据
            优化了写法，冗余了一个onlyRead的数据提供给读，减少了加锁对性能的消耗
            读的时候先从onlyRead读，没得再加锁读dirty  如果miss超过一定数量就会将dirty提升到onlyRead
            写的时候也要从看下onlyRead有数据没,有的话保存到onlyRead里面 ， 没有的话加锁执行
            遍历，看dirty里面是否有新数据 有就提升到onlyRead 然后开读
            使用场景：读多写少

        10.redis的内存管理：
            1.过期key回收
                1.定期过期：
                    设置了定时的会被单独放进一个字典里，每隔段时间进行扫描并删除，贪心删除：随机挑X个删除其中过期的如果超过Y个就循环该步骤
                2.惰性删除：
                    当被访问时是已过期的就删除
            2.del大内存数据怎么优化
                unlink 命令，让redis异步删除
            3.内存到了瓶颈时怎么淘汰内存
                近似LRU，随机拿X个KEY 进入淘汰池，再从淘汰池删除最旧的key

        11.redis的skiplist的插入
            如果正常的skiplist，插入后他后面的数据都要重排
            redis的skiplist做了个随机层数，直接找到对应位置插入，logn

        12.为什么选用redis做缓存
        13.golang 内存管理知道那些？
            GC：
                1. 先判断是否正在执行GC。
                2. stw,收集所有根对象（栈、堆、var）、启动写屏障,stw结束
                3. 标记对象，直到标记完所有根对象和根对象可达对象。此时写屏障会记录所有指针的更改(通过 mutator)。
                4. stw 标记写屏障产生的内容 stw结束
                5. 并发的清除未标记的对象。
            内存分配：
                堆、栈
            内存逃逸：
                栈数据 分配到 堆上

    算法题：
        一堆重复数字里面找出不同的数字，不能用map
        答：排序+比较